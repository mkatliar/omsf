##
## Copyright (c) 2015-2018 Mikhail Katliar, Max Planck Institute for Biological Cybernetics.
## 
## This file is part of Offline Motion Simulation Framework (OMSF) 
## (see https://github.com/mkatliar/omsf).
## 
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU Lesser General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU Lesser General Public License for more details.
## 
## You should have received a copy of the GNU Lesser General Public License
## along with this program. If not, see <http://www.gnu.org/licenses/>.
##
'''
@author: mkatliar
'''
import omsf, omsf.util as util
import numpy as np
import casadi as cs


def loadRecordedMotion(filename):
    '''Loads and processes CarSim IMU data file.
    
    @param filename - file name of a file with data generated by CarSim.
    The format is delimited text file with the following columns:
    3 x Linear Acceleration in CG in g units (1-3)
    3 x Angular Velocity in CG in deg/s (4-6)
    3 x Global Position of the Car (7-9)
    3 x Orientation of the Car(in BodyFrame) in deg (10-12)
    3 x Linear Acceleration in IMU Sensor (Gravity Compensated) in g-units
    3 x Angular Velocity in IMU Sensor in deg/s
    1 x Simulation Timestamp
    
    @return: RecordedMotion object
    '''

    data = np.loadtxt(filename)
    assert data.shape[1] == 19
    
    t = data[:, 18]
    r     = data[:, 6 : 9].transpose()   # Position in world frame.
    a     = data[:, 12 : 15].transpose() * np.linalg.norm(omsf.DEFAULT_GRAVITY)   # lin acc in IMU, m/s^2
    omega = np.deg2rad(data[:, 15 : 18].transpose())    # Ang. vel. in IMU, radians/s
    roll  = np.deg2rad(data[:, 9])          # Roll angle, radians
    pitch = np.deg2rad(data[:, 10])         # Pitch angle in deg
    yaw   = np.deg2rad(data[:, 11])         # Yaw angle in deg
    
    # Velocity vector in world frame.
    v_world = util.time_derivative(data[:, 6 : 9].transpose(), t)
    
    # initialize matrices
    v_imu = np.zeros([3, len(t)])
    v_imu.fill(np.NaN)
    
    g_imu = np.zeros([3, len(t)])
    g_imu.fill(np.NaN)
    
    T_world_2_imu = np.tile(np.atleast_3d(np.eye(4)), [1, 1, len(t)]);
    
    for i in range(len(t)):
        # Use Euler angles and position to compute transformation matrix from world frame to IMU frame.
        T_imu_2_world = cs.mtimes([
            omsf.transform.translation(r[:, i]), 
            omsf.transform.rotationZ(yaw[i]), 
            omsf.transform.rotationY(pitch[i]),
            omsf.transform.rotationX(roll[i])
        ])
                                  
        T_world_2_imu[:, :, i] = np.linalg.inv(T_imu_2_world)
          
        R_world_imu = omsf.transform.getRotationMatrix(T_world_2_imu[:, :, i])
        v_imu[:, i] = np.dot(R_world_imu, v_world[:, i])
        g_imu[:, i] = np.dot(R_world_imu, omsf.DEFAULT_GRAVITY)
    
    # collect data in object
    return omsf.RecordedMotion(t, v=v_imu, gia=a - g_imu, omega=omega, world_to_local=T_world_2_imu)
