##
## Copyright (c) 2015-2018 Mikhail Katliar, Max Planck Institute for Biological Cybernetics.
## 
## This file is part of Offline Motion Simulation Framework (OMSF) 
## (see https://github.com/mkatliar/omsf).
## 
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU Lesser General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU Lesser General Public License for more details.
## 
## You should have received a copy of the GNU Lesser General Public License
## along with this program. If not, see <http://www.gnu.org/licenses/>.
##
'''
Created on Jan 26, 2015

@author: mkatliar
'''
import omsf
import numpy.linalg, scipy.io


def loadRecordedMotion(filename):
    '''Load and process ViaSync IMU data file.
    
    @param filename - file name of a file with data generated by CarSim.
    
    The format is delimited text file with the following columns:
    3 x Linear Acceleration in CG in g units (1-3)
    3 x Angular Velocity in CG in deg/s (4-6)
    3 x Global Position of the Car (7-9)
    3 x Orientation of the Car(in BodyFrame) in deg (10-12)
    3 x Linear Acceleration in IMU Sensor (Gravity Compensated) in g-units
    3 x Angular Velocity in IMU Sensor in deg/s
    1 x Simulation Timestamp
    
    @return RecordedMotion object

    The IMU uses a right hand coordinate system with the x-axis pointing
    right, y forward and z up. Linear acceleration (x-y-z) and angular rates
    (p,q r] are expressed regarding those axes. (e.g. ax = lateral
    acceleration, and p = rotation about x, = pitch)
    Note that the euler angles  phi, theta psi still denote roll, (around y), 
    pitch (around x) and yaw (around z), The heading angle (azimuth) is expressed 
    relative to North, following the left hand rule, so the euler angle psi =
    - azimuth.
    Angles and angular rates are expressed in deg (/s)
    '''

    data    =   scipy.io.loadmat(filename)['DATA']
    phi     =   numpy.deg2rad(data['phi'][0][0]).squeeze();     # conversion to radians
    theta   =   numpy.deg2rad(data['theta'][0][0]).squeeze();   # conversion to radians
    psi     = - numpy.deg2rad(data['psi'][0][0]).squeeze();     # conversion of azimuth to psi, in rad
    t       =   data['t'][0][0].squeeze()

    # Velocity vector in world frame.
    v_world = numpy.hstack((data['vel_east'][0][0], data['vel_north'][0][0], data['vel_up'][0][0])).T

    # initialize matrices
    Nt = len(t)
    v_imu = numpy.zeros((3, Nt))
    g_imu = numpy.zeros((3, Nt))
    T_world_2_imu = numpy.tile(numpy.atleast_3d(numpy.identity(4)), Nt)

    for i in range(Nt):
        '''
        Use data.phi(i), data.theta(i), data.psi(i) to compute transformation matrix from world frame to IMU frame.
            
        The transformation matrix is formed by: inv([Rz(psi) * Rx(theta) * Ry(phi)])
        Note that rotation order is still roll-pitch-yaw, but that roll is
        coupled to the y-axis and pitch to the x-axis!
        
        TODO: the transformation matrix below does not contain the
        translational part, i.e. the position information is lost. It can be
        added based on the lat, long and alt fields though.
        '''
        
        T_imu_2_world = numpy.dot(numpy.dot(omsf.transform.rotationZ(psi[i]), omsf.transform.rotationX(theta[i])), omsf.transform.rotationY(phi[i]));
        T_world_2_imu[:, :, i] = numpy.linalg.inv(T_imu_2_world)
          
        R_world_imu = omsf.transform.getRotationMatrix(T_world_2_imu[:, :, i])
        v_imu[:, i] = numpy.dot(R_world_imu, v_world[:, i])
        g_imu[:, i] = numpy.dot(R_world_imu, numpy.array(omsf.DEFAULT_GRAVITY))

    # collect data in object
    result = omsf.RecordedMotion(t, v = v_imu, gia = numpy.hstack((data['ax'][0][0], data['ay'][0][0], data['az'][0][0])).T - g_imu, \
        omega = numpy.deg2rad(numpy.hstack((data['p'][0][0], data['q'][0][0], data['r'][0][0])).T), world_to_local = T_world_2_imu)

    # Cut first 50ms of data, which are usually invalid in VIASync.
    cut_at_start = 0.05
    result = result.Cut(result.time[0] + cut_at_start, numpy.Inf)
    
    return result